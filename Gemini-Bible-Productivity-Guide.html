<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini 바이블: 구글 AI를 활용한 10배의 업무 생산성 향상 가이드</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for Markdown to HTML conversion -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for rendered markdown */
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
        }
        .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4 {
            font-weight: 700;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.3em;
        }
        .markdown-body h1 { font-size: 2.25rem; }
        .markdown-body h2 { font-size: 1.875rem; }
        .markdown-body h3 { font-size: 1.5rem; }
        .markdown-body h4 { font-size: 1.25rem; }
        .markdown-body p {
            line-height: 1.75;
            margin-bottom: 1em;
        }
        .markdown-body ul, .markdown-body ol {
            margin-left: 1.5em;
            margin-bottom: 1em;
            list-style-position: outside;
        }
        .markdown-body ul { list-style-type: disc; }
        .markdown-body ol { list-style-type: decimal; }
        .markdown-body li { margin-bottom: 0.5em; }
        .markdown-body a {
            color: #2563eb;
            text-decoration: underline;
        }
        .markdown-body a:hover {
            color: #1d4ed8;
        }
        .markdown-body code {
            background-color: #f1f5f9;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
        }
        .markdown-body pre {
            background-color: #1f2937;
            color: #f9fafb;
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1em;
        }
        .markdown-body pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        .markdown-body table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1em;
        }
        .markdown-body th, .markdown-body td {
            border: 1px solid #cbd5e1;
            padding: 0.75em;
            text-align: left;
        }
        .markdown-body th {
            background-color: #f1f5f9;
            font-weight: 600;
        }
        .markdown-body blockquote {
            border-left: 4px solid #9ca3af;
            padding-left: 1em;
            margin-left: 0;
            color: #4b5563;
        }
        .markdown-body hr {
            border-top: 1px solid #e5e7eb;
            margin: 2em 0;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <main class="max-w-4xl mx-auto p-4 sm:p-8 my-8 bg-white rounded-xl shadow-lg">
        <!-- The markdown content will be rendered inside this div -->
        <div id="content" class="markdown-body"></div>
    </main>

    <script>
        // The entire markdown content from the document
        const markdownContent = `
# Gemini 바이블: 구글 AI를 활용한 10배의 업무 생산성 향상 가이드

---

## Part 1: 업무 환경을 위한 생성형 AI의 기초

이 첫 번째 파트는 사용자가 정확하고 안전하며 현대적인 개발 환경에서 시작할 수 있도록 보장하는 데 중점을 둡니다. 다양한 SDK 버전으로 인한 혼란을 해소하고, 기업 환경에서 필수적인 API 키 관리 모범 사례를 확립합니다.

### Chapter 1: Gemini 생태계 입문

#### 패러다임의 전환: 멀티모달 AI란 무엇인가?

생성형 인공지능의 발전은 단순히 더 나은 챗봇의 등장을 의미하지 않습니다. 이는 정보 처리 방식의 근본적인 변화를 예고하며, 그 중심에 '멀티모달(Multimodal) AI'가 있습니다. 전통적인 AI 모델이 주로 텍스트라는 단일 양식(modality)의 데이터를 처리하는 데 국한되었다면, 구글의 Gemini는 텍스트, 이미지, 오디오, 비디오 등 여러 양식의 정보를 동시에 이해하고 처리할 수 있는 능력을 갖추고 있습니다.[1, 2, 3]

이러한 멀티모달리티는 Gemini를 단순한 언어 모델이 아닌, 포괄적인 정보 처리 엔진으로 격상시킵니다. 예를 들어, 사용자는 회의 녹음 파일(오디오), 발표 자료(이미지/텍스트), 그리고 관련 이메일(텍스트)을 Gemini에 한 번에 제공하고 "이 회의의 핵심 결정 사항을 요약하고, 관련 자료를 바탕으로 후속 조치 항목을 정리해 줘"라고 요청할 수 있습니다. Gemini는 각기 다른 형태의 데이터를 종합적으로 분석하여 인간 전문가와 유사한 수준의 통찰력을 제공합니다. 이 능력은 복잡한 비즈니스 문제를 해결하고, 이전에는 불가능했던 수준의 자동화 워크플로우를 구축하는 기반이 됩니다. 본 가이드의 후반부에서 다룰 고급 워크플로우들은 모두 이 멀티모달리티라는 핵심 개념 위에 구축됩니다.

#### 모델 소개: 올바른 도구 선택하기

Gemini 생태계는 다양한 성능과 비용 특성을 가진 모델 제품군으로 구성되어 있어, 사용자는 특정 작업에 가장 적합한 도구를 선택할 수 있습니다. 각 모델의 특성을 이해하는 것은 효율성과 비용 최적화의 첫걸음입니다. 주요 모델은 다음과 같습니다.[2]

* **Gemini Flash:** 속도와 효율성에 최적화된 경량 모델입니다. 실시간 챗봇, 대량의 텍스트 요약, 빠른 응답이 중요한 애플리케이션에 적합합니다. 비용 효율성이 높아 반복적인 자동화 작업에 이상적입니다.
* **Gemini Pro:** 높은 성능과 범용성을 균형 있게 갖춘 표준 모델입니다. 대부분의 비즈니스 분석, 콘텐츠 생성, 복잡한 지시 이해 등 광범위한 작업에 신뢰성 있는 결과를 제공합니다.
* **Gemini Ultra:** 가장 강력한 성능을 지닌 플래그십 모델로, 매우 복잡하고 미묘한 추론이 필요한 작업에 사용됩니다. 심층적인 연구 분석, 전문적인 코드 생성, 다중 모달 정보의 복합적인 이해가 필요할 때 최상의 성능을 발휘합니다.

업무 생산성을 극대화하기 위해서는 단순히 가장 강력한 모델을 사용하는 것이 아니라, 주어진 과업의 복잡성과 요구되는 응답 속도, 그리고 예산을 고려하여 최적의 모델을 전략적으로 선택해야 합니다. 예를 들어, 수백 개의 고객 리뷰를 분류하는 작업에는 Gemini Flash를, 분기별 실적 보고서 초안을 작성하는 작업에는 Gemini Pro를 사용하는 것이 합리적입니다.[1, 2]

##### 주요 표: Gemini 모델 선택 가이드

| 모델명 (API 호출 시) | 주요 비즈니스 활용 사례 | 핵심 특징 | 상대적 비용/성능 |
| :--- | :--- | :--- | :--- |
| \`gemini-1.5-flash-latest\` | 실시간 챗봇, 대규모 문서 요약, 고객 문의 분류 | 빠른 응답 속도, 긴 컨텍스트 창(최대 100만 토큰), 비용 효율성 | 낮음 / 우수 |
| \`gemini-1.5-pro-latest\` | 심층 보고서 작성, 복잡한 데이터 분석, 멀티모달 정보 처리 | 높은 정확도, 멀티모달 입력(텍스트, 이미지, 비디오), 고급 추론 능력 | 중간 / 최상 |
| \`gemini-pro\` | 일반적인 콘텐츠 생성, 이메일 초안 작성, 아이디어 브레인스토밍 | 안정적인 텍스트 생성 능력, 범용성 | 중간 / 좋음 |
| \`gemini-ultra\` | 전문 분야 연구, 고도의 복잡한 문제 해결, 전략 수립 | 최고 수준의 성능, 최첨단 추론 능력 (제한적 접근) | 높음 / 최고 |

#### 개발 환경 설정하기

효과적인 Gemini 활용을 위해 안정적이고 현대적인 개발 환경을 구축하는 것은 필수적입니다. 이 과정에서 발생할 수 있는 혼란을 방지하고, 기업 환경에 맞는 보안 관행을 처음부터 적용하는 것이 중요합니다.

##### Gemini SDK: 최신 버전 선택의 중요성

Gemini API를 파이썬에서 사용하기 위한 SDK(Software Development Kit)는 현재 진화 과정에 있습니다. 기존의 \`google-generativeai\` 패키지와 새롭게 권장되는 \`google-genai\` 패키지가 공존하고 있어 혼란을 야기할 수 있습니다.[4] 다양한 온라인 튜토리얼에서 두 가지 패키지 이름이 혼용되어 사용되는 경우가 많기 때문입니다.[1, 5]

\`google-generativeai\`는 레거시(legacy) 라이브러리로, 2025년 11월 30일부로 지원이 종료될 예정이며 더 이상 새로운 기능 업데이트가 제공되지 않습니다. 반면, \`google-genai\`는 최신 기능을 모두 지원하는 현대적인 SDK입니다. 따라서 학습의 지속성과 최신 기능(예: Live API, Veo) 활용을 위해 반드시 \`google-genai\` 패키지를 설치하고 사용해야 합니다. 본 가이드는 \`google-genai\`를 기준으로 모든 예제를 설명하여, 독자의 학습이 미래에도 유효하도록 보장합니다.

**1. Python SDK 설치**

터미널 또는 Jupyter Notebook 셀에서 다음 명령어를 실행하여 최신 Gemini SDK를 설치합니다. \`-q\` (quiet) 옵션은 설치 과정을 간결하게 표시하고, \`-U\` (upgrade) 옵션은 이미 설치된 경우 최신 버전으로 업데이트합니다.

\`\`\`python
!pip install -q -U google-genai
\`\`\`

**2. API 키 발급**

Gemini API를 사용하려면 인증을 위한 API 키가 필요합니다. 이 키는 Google AI Studio 웹사이트에서 발급받을 수 있습니다.[1, 6]

1. ([https://aistudio.google.com/)에](https://aistudio.google.com/)에) 접속하여 구글 계정으로 로그인합니다.
2.  좌측 메뉴에서 'Get API key'를 클릭합니다.
3.  'Create API key' 버튼을 눌러 새로운 API 키를 생성합니다.
4.  생성된 API 키 문자열을 복사하여 안전한 곳에 보관합니다. 이 키는 외부에 노출되지 않도록 주의해야 합니다.

**3. 기업 환경을 위한 보안 모범 사례: API 키 관리**

API 키를 코드에 직접 하드코딩하는 것은 심각한 보안 위험을 초래할 수 있습니다. 특히, 코드를 버전 관리 시스템(예: Git)에 공유할 경우 키가 유출될 수 있습니다. 기업 환경에서는 다음과 같은 안전한 방법을 사용해야 합니다.

* **환경 변수(Environment Variables) 사용:** 가장 일반적이고 권장되는 방법입니다. 운영 체제에 API 키를 환경 변수로 저장하고, 코드에서는 이 변수를 읽어오는 방식입니다.
* **비밀 관리 도구(Secrets Management Tools):** Google Colab의 'Secrets' 기능이나, 클라우드 환경의 AWS Secrets Manager, Google Secret Manager, HashiCorp Vault와 같은 전문 도구를 사용하는 것이 더욱 안전합니다.

본 가이드에서는 Google Colab의 Secrets 기능을 사용하는 방법을 기준으로 설명합니다.

1.  Google Colab의 왼쪽 패널에서 열쇠 모양(🔑) 아이콘을 클릭하여 'Secrets' 탭을 엽니다.
2.  'Add a new secret'을 클릭합니다.
3.  'Name' 필드에 \`GEMINI_API_KEY\`를 입력합니다.
4.  'Value' 필드에 발급받은 API 키를 붙여넣습니다.
5.  'Notebook access'를 활성화하여 이 노트북에서 해당 비밀에 접근할 수 있도록 허용합니다.

**4. 첫 번째 API 호출: 환경 설정 확인**

이제 모든 설정이 올바르게 완료되었는지 확인하기 위해 간단한 텍스트 생성 요청을 보내봅니다. 아래 코드는 Colab의 Secrets에 저장된 API 키를 안전하게 불러와 SDK를 설정하고, "AI는 무엇인가?"라는 질문에 대한 답변을 생성하는 예제입니다.[5, 7]

\`\`\`python
# Jupyter Notebook (Google Colab)

import google.generativeai as genai
from google.colab import userdata
import os

# Colab Secrets에서 API 키를 가져옵니다.
# 로컬 환경에서는 os.environ.get('GEMINI_API_KEY') 와 같은 방식을 사용합니다.
try:
    api_key = userdata.get('GEMINI_API_KEY')
    genai.configure(api_key=api_key)
except userdata.SecretNotFoundError as e:
    print(f"Secret not found: Make sure you have stored your API key as a secret named 'GEMINI_API_KEY'.")
    api_key = None
except Exception as e:
    print(f"An error occurred: {e}")
    api_key = None

if api_key:
    # 사용할 모델을 초기화합니다.
    # 'gemini-1.5-flash-latest'는 빠르고 효율적인 모델입니다.
    model = genai.GenerativeModel('gemini-1.5-flash-latest')

    # 모델에 텍스트 생성을 요청합니다.
    prompt = "AI(인공지능)란 무엇인지 한 문장으로 설명해줘."
    response = model.generate_content(prompt)

    # 생성된 텍스트를 출력합니다.
    print(response.text)

\`\`\`

위 코드를 실행했을 때 AI의 답변이 성공적으로 출력된다면, Gemini를 활용할 모든 준비가 완료된 것입니다.

### Chapter 2: 프롬프트 엔지니어링의 기술과 과학

Gemini와 같은 대규모 언어 모델(LLM)의 잠재력을 최대한 끌어내는 핵심은 '프롬프트 엔지니어링(Prompt Engineering)'에 있습니다. 이는 단순히 질문을 던지는 것을 넘어, 모델이 최상의 결과를 생성하도록 유도하는 명확하고 구조화된 지시를 설계하는 과정입니다. 효과적인 프롬프트는 모호한 요청을 정밀한 명령으로 바꾸는 '프로그래밍'의 한 형태와 같습니다.

#### 모호한 요청에서 정밀한 지시로

모델에게 좋은 결과를 얻기 위한 프롬프트의 기본 원칙은 다음과 같습니다.

* **명확한 맥락 제공 (Context):** 모델이 사용자의 상황을 이해할 수 있도록 충분한 배경 정보를 제공해야 합니다. 예를 들어, "보고서 요약해줘"보다는 "나는 IT 부서의 프로젝트 관리자다. 다음 주간 회의 보고서를 바탕으로, 경영진에게 보고할 3가지 핵심 성과와 2가지 주요 리스크를 요약해줘."가 훨씬 더 좋은 결과를 낳습니다.
* **원하는 형식 정의 (Format):** 결과물이 어떤 형태로 나와야 하는지 구체적으로 명시해야 합니다. "글머리 기호 목록 형태로", "JSON 형식으로 키-값 쌍을 사용하여", "마크다운 테이블로 정리하여"와 같이 출력 형식을 지정하면 후속 자동화 작업이 용이해집니다.
* **제약 조건 설정 (Constraints):** 결과물의 길이, 톤앤매너, 포함하거나 제외할 내용 등 제약 조건을 명확히 해야 합니다. "500자 이내로", "전문적이고 격식 있는 어조로", "가격 정보는 제외하고 기능에만 초점을 맞춰서"와 같은 지시가 포함될 수 있습니다.

#### 우수한 결과를 위한 고급 프롬프팅 기법

기본 원칙을 넘어, 모델의 성능을 극적으로 향상시키는 고급 기법들이 존재합니다.

##### Few-Shot 프롬프팅: 예시를 통한 학습

Few-Shot 프롬프팅은 모델에게 원하는 결과물의 예시(shot)를 몇 개 제공하여, 모델이 출력의 형식과 스타일을 학습하도록 유도하는 강력한 기법입니다. 이는 모델에게 추상적인 지시를 내리는 것보다 훨씬 효과적입니다.

**예제: 고객 리뷰 감성 분석**

\`\`\`python
# Jupyter Notebook

import google.generativeai as genai

# API 키 설정은 이전 챕터에서 완료되었다고 가정합니다.
if api_key:
    model = genai.GenerativeModel('gemini-1.5-flash-latest')

    # Few-Shot 프롬프트 구성
    few_shot_prompt = """
    다음 고객 리뷰 텍스트를 '긍정', '부정', '중립' 세 가지 카테고리 중 하나로 분류하세요.

    리뷰: "배송이 정말 빠르고 제품 품질도 만족스럽습니다."
    분류: 긍정

    리뷰: "기대했던 것보다 색상이 너무 어둡네요. 실망입니다."
    분류: 부정

    리뷰: "포장은 꼼꼼하게 잘 되어 왔습니다."
    분류: 중립

    리뷰: "가격 대비 성능이 놀라울 정도로 좋습니다. 재구매 의사 있습니다!"
    분류:
    """

    response = model.generate_content(few_shot_prompt)
    print(f"분류 결과: {response.text}")
\`\`\`
이처럼 예시를 제공하면, 모델은 단순히 텍스트의 의미를 파악하는 것을 넘어 사용자가 원하는 '분류'라는 특정 작업과 '긍정', '부정', '중립'이라는 출력 형식을 명확하게 이해하게 됩니다.

##### 메타 프롬프팅: 모델의 사고방식 설계하기

메타 프롬프팅(Meta-Prompting)은 모델에게 과업 자체를 주기 전에, 과업에 접근하는 방식이나 역할을 먼저 지시하는 한 차원 높은 기법입니다.[8] 이는 모델이 어떻게 생각해야 하는지에 대한 '메타(meta)' 지시를 내리는 것과 같습니다. 이 기법을 통해 사용자는 일반적인 사용자에서 모델의 행동을 정교하게 제어하는 파워 유저로 거듭날 수 있습니다.

메타 프롬프팅의 핵심 요소는 다음과 같습니다.

* **페르소나(Persona) 부여:** 모델에게 특정 전문가의 역할을 부여합니다. "당신은 20년 경력의 재무 분석가입니다.", "당신은 기술에 익숙하지 않은 독자를 위한 과학 칼럼니스트입니다." 와 같이 페르소나를 지정하면, 결과물의 깊이와 어조가 해당 역할에 맞게 극적으로 달라집니다.
* **사고의 연쇄(Chain-of-Thought, CoT) 유도:** 복잡한 문제를 해결해야 할 때, 모델에게 최종 답변만 요구하는 대신 생각의 과정을 단계별로 설명하도록 지시합니다. "단계별로 생각해서 설명해줘(Think step-by-step)"라는 간단한 문구만 추가해도 모델의 추론 능력이 향상되어 더 정확한 답변을 생성하는 경향이 있습니다.
* **출력 구조 명세:** 원하는 결과물의 구조를 명확하게 정의합니다. 이는 단순히 JSON이나 마크다운을 요청하는 것을 넘어, 구체적인 스키마나 템플릿을 제공하는 것을 포함합니다.[9]

**예제: 메타 프롬프팅을 활용한 시장 분석 요청**

\`\`\`python
# Jupyter Notebook

if api_key:
    model = genai.GenerativeModel('gemini-1.5-pro-latest') # 더 복잡한 작업을 위해 Pro 모델 사용

    meta_prompt = """
    # 페르소나
    당신은 신규 사업 전략을 수립하는 전문 비즈니스 컨설턴트입니다.

    # 지시사항
    아래 제공된 '신제품 아이디어'에 대해 시장 진입 전략 보고서의 초안을 작성하세요.
    다음 단계를 반드시 순서대로 따라서思考하고, 각 단계의 결과를 명확하게 서술하세요.

    1.  **핵심 타겟 고객층 정의:** 이 제품을 가장 필요로 할 고객 그룹을 3개로 세분화하고, 각 그룹의 특징을 설명하세요.
    2.  **주요 경쟁사 분석:** 시장의 주요 경쟁사 2곳을 선정하고, 그들의 강점과 약점을 분석하세요.
    3.  **차별화 전략 제안:** 우리 제품이 경쟁사와 차별화될 수 있는 핵심 포인트를 3가지 제안하세요.

    # 출력 형식
    최종 결과는 아래의 마크다운 형식에 맞춰 작성하세요.
    ## 시장 진입 전략 보고서: [제품명]
    ### 1. 핵심 타겟 고객층
    - **그룹 1:** [설명]
    - **그룹 2:** [설명]
    - **그룹 3:** [설명]
    ### 2. 주요 경쟁사 분석
    - **경쟁사 A:**
        - 강점: [내용]
        - 약점: [내용]
    - **경쟁사 B:**
        - 강점: [내용]
        - 약점: [내용]
    ### 3. 차별화 전략
    1.  [전략 1]
    2.  [전략 2]
    3.  [전략 3]

    ---
    # 신제품 아이디어
    제품명: AI 기반 자동 회의록 정리 서비스
    기능: 화상 회의 음성을 실시간으로 텍스트 변환하고, 핵심 요약 및 할 일 목록을 자동으로 추출하여 이메일로 발송함.
    """

    response = model.generate_content(meta_prompt)
    from IPython.display import display, Markdown
    display(Markdown(response.text))
\`\`\`

#### 자동화를 위한 입출력 구조화: JSON과 마크다운 활용

업무 생산성 향상의 핵심은 반복 작업을 자동화하는 데 있으며, 이를 위해서는 AI의 출력이 기계가 쉽게 읽고 처리할 수 있는(machine-readable) 예측 가능한 형태여야 합니다. JSON(JavaScript Object Notation)과 마크다운(Markdown)은 이러한 구조화된 출력을 얻기 위한 가장 효과적인 형식입니다.

프롬프트에 "결과는 반드시 RFC 8259 표준을 준수하는 JSON 형식으로 반환해줘. 'name', 'email', 'phone' 키를 포함해야 해." 와 같이 명시하면, Gemini는 텍스트 응답이 아닌 파싱 가능한 데이터 구조를 반환합니다. 이 JSON 출력은 파이썬의 \`json\` 라이브러리를 통해 즉시 딕셔너리 객체로 변환되어 데이터베이스에 저장하거나, 다른 API의 입력으로 사용하는 등 후속 자동화 파이프라인에 완벽하게 통합될 수 있습니다. 이는 비정형 텍스트에서 정형 데이터를 추출하는 강력한 방법이며, 수작업 데이터 입력을 대체하여 막대한 시간을 절약할 수 있습니다.

---

## Part 2: 핵심 비즈니스 커뮤니케이션 및 문서화 자동화

이 파트에서는 Part 1에서 학습한 기초 기술을 바탕으로, 시간이 많이 소요되는 일반적인 사무 업무를 자동화하는 실질적인 예제들을 다룹니다. 각 예제는 그 자체로 하나의 완성된 생산성 도구 역할을 하도록 설계되었습니다.

### Chapter 3: 텍스트 생성 및 변환 마스터하기

Gemini의 강력한 언어 생성 능력을 활용하여 커뮤니케이션과 문서 작성의 효율성을 극대화하는 방법을 탐구합니다. 이메일 초안 작성부터 보고서 요약, 콘텐츠 스타일 변환까지 다양한 시나리오를 실습합니다.

#### 자동화된 커뮤니케이션 허브

반복적인 이메일과 보고서 작성은 많은 직장인의 시간을 소모합니다. Gemini를 활용하면 몇 가지 핵심 정보만으로 완성도 높은 초안을 즉시 생성할 수 있습니다.

##### 실습: 핵심 내용 기반 이메일 초안 작성기

다음은 몇 개의 글머리 기호로 정리된 핵심 내용을 바탕으로, 격식 있는 비즈니스 이메일 초안을 생성하는 파이썬 스크립트입니다.

\`\`\`python
# Jupyter Notebook

import google.generativeai as genai
from IPython.display import display, Markdown

# API 키 설정은 완료되었다고 가정합니다.
if api_key:
    model = genai.GenerativeModel('gemini-1.5-flash-latest')

    def draft_email(recipient_name, sender_name, key_points):
        """
        핵심 내용을 바탕으로 비즈니스 이메일 초안을 생성합니다.
        """
        prompt = f"""
        # 지시사항
        당신은 프로페셔널한 비즈니스 커뮤니케이터입니다.
        아래 '핵심 내용'을 바탕으로, 정중하고 명료한 비즈니스 이메일 초안을 작성하세요.

        - 수신자: {recipient_name}
        - 발신자: {sender_name}
        - 어조: 공식적이고 긍정적
        - 형식: 표준 비즈니스 이메일 형식 (인사, 본문, 맺음말, 서명)

        # 핵심 내용
        {key_points}

        # 이메일 초안
        """
        response = model.generate_content(prompt)
        return response.text

    # 이메일 작성을 위한 정보
    recipient = "김민준 팀장님"
    sender = "박서연 드림"
    points = """
    - 3분기 '알파 프로젝트' 실적 보고
    - 목표 대비 115% 초과 달성
    - 주요 성공 요인은 신규 마케팅 전략과 팀원들의 헌신
    - 상세 보고서는 첨부 파일로 전달 예정
    - 다음 주 중 간단한 결과 공유 미팅 제안
    """

    # 이메일 생성 및 출력
    email_draft = draft_email(recipient, sender, points)
    display(Markdown(email_draft))
\`\`\`

##### 실습: 개요 기반 보고서 초안 생성

구조화된 개요만 있다면, Gemini는 살을 붙여 논리적인 흐름을 갖춘 보고서의 초안을 작성할 수 있습니다. 이는 문서 작업의 시작 단계에서 겪는 '빈 페이지의 공포'를 극복하는 데 큰 도움이 됩니다.

\`\`\`python
# Jupyter Notebook

if api_key:
    model = genai.GenerativeModel('gemini-1.5-pro-latest') # 더 긴 텍스트 생성을 위해 Pro 모델 사용

    def generate_report_draft(title, outline):
        """
        개요를 바탕으로 보고서 초안을 생성합니다.
        """
        prompt = f"""
        # 지시사항
        당신은 전문 보고서 작성가입니다.
        아래 제공된 '제목'과 '개요'를 바탕으로 상세하고 논리적인 보고서 초안을 작성하세요.
        각 개요 항목에 대해 최소 2~3문단의 설명을 추가하세요.

        # 제목
        {title}

        # 개요
        {outline}
        """
        response = model.generate_content(prompt)
        return response.text

    # 보고서 정보
    report_title = "2025년 상반기 소셜 미디어 마케팅 성과 분석 보고서"
    report_outline = """
    1. 서론
       - 보고서의 목적 및 범위
       - 상반기 마케팅 목표 요약

    2. 주요 플랫폼별 성과 분석
       - 인스타그램: 참여율 변화 및 주요 캠페인 결과
       - 유튜브: 구독자 증가 추이 및 동영상 콘텐츠 성과
       - 틱톡: 신규 사용자 유입 및 바이럴 콘텐츠 분석

    3. 종합 성과 평가
       - KPI 달성률 분석 (도달률, 전환율 등)
       - ROI(투자 대비 수익률) 평가

    4. 결론 및 하반기 제언
       - 상반기 성과 요약 및 시사점
       - 하반기 전략 개선 방향 제안
    """

    # 보고서 초안 생성 및 출력
    report_draft = generate_report_draft(report_title, report_outline)
    display(Markdown(report_draft))
\`\`\`

#### 정보 추출기: 자동 요약

방대한 양의 정보 속에서 핵심을 빠르게 파악하는 능력은 현대 비즈니스 환경의 필수 역량입니다. Gemini를 사용하면 긴 기사, 연구 논문, 회의록 등을 몇 초 만에 간결한 요약본으로 만들 수 있습니다.

##### 실습: 긴 텍스트를 위한 경영진 요약(Executive Summary) 생성기

\`\`\`python
# Jupyter Notebook

if api_key:
    model = genai.GenerativeModel('gemini-1.5-flash-latest')

    def create_executive_summary(text):
        """
        긴 텍스트를 바탕으로 경영진을 위한 핵심 요약을 생성합니다.
        """
        prompt = f"""
        # 페르소나
        당신은 바쁜 최고 경영자(CEO)를 위해 보고서를 요약하는 유능한 비서입니다.

        # 지시사항
        아래 '원본 텍스트'의 핵심 내용을 정확하고 간결하게 요약하세요.
        요약은 다음 내용을 반드시 포함해야 합니다:
        1.  문제 상황 또는 배경
        2.  핵심 결과 또는 발견
        3.  주요 제언 또는 다음 단계

        # 출력 형식
        3~5개의 핵심 불릿 포인트로 정리하세요.

        # 원본 텍스트
        {text}
        """
        response = model.generate_content(prompt)
        return response.text

    # 요약할 긴 텍스트 (예시)
    long_text = """
    (여기에 수 페이지 분량의 시장 조사 보고서, 기술 문서, 또는 긴 기사 내용을 붙여넣습니다.)
   ... (중략)...
    결론적으로, A/B 테스트 결과 '디자인 B'가 '디자인 A'에 비해 사용자 전환율을 15% 더 높이는 것으로 나타났습니다.
    이는 버튼 색상과 문구의 미세한 차이가 사용자 행동에 큰 영향을 미친다는 것을 시사합니다.
    따라서, 모든 서비스 페이지의 CTA 버튼을 '디자인 B' 스타일로 즉시 변경할 것을 제안합니다.
    또한, 향후 모든 디자인 변경 시에는 소규모 A/B 테스트를 의무화하는 프로세스를 도입해야 합니다.
    """

    summary = create_executive_summary(long_text)
    display(Markdown(summary))
\`\`\`

#### 콘텐츠 카멜레온: 톤앤매너 및 스타일 변환

하나의 콘텐츠를 다양한 대상과 목적에 맞게 변형하는 작업은 상당한 노력을 요구합니다. Gemini를 활용하면 기술 문서를 마케팅 문구로, 격식 있는 공지사항을 친근한 소셜 미디어 게시물로 쉽게 변환할 수 있습니다.

##### 실습: 대상 독자에 맞춰 텍스트 재작성하기

\`\`\`python
# Jupyter Notebook

if api_key:
    model = genai.GenerativeModel('gemini-1.5-flash-latest')

    def rewrite_text_for_audience(text, target_audience):
        """
        주어진 텍스트를 특정 대상 독자에 맞게 재작성합니다.
        """
        prompt = f"""
        # 지시사항
        아래 '원본 텍스트'를 '{target_audience}'가 이해하기 쉽고 흥미를 느낄 만한 스타일로 재작성하세요.

        # 원본 텍스트
        {text}
        """
        response = model.generate_content(prompt)
        return response.text

    # 원본 기술 설명
    original_text = "본 제품은 256비트 AES 암호화 알고리즘을 적용한 엔드-투-엔드 암호화(E2EE)를 통해 데이터 전송 구간의 보안성을 극대화하였습니다."

    # 대상 독자별로 재작성
    marketing_copy = rewrite_text_for_audience(original_text, "잠재 고객을 위한 마케팅 광고 문구")
    internal_memo = rewrite_text_for_audience(original_text, "비기술직군 동료를 위한 내부 공지")
    social_media_post = rewrite_text_for_audience(original_text, "10대들을 위한 인스타그램 게시물")

    print("--- 마케팅 광고 문구 ---")
    print(marketing_copy)
    print("\\n--- 내부 공지 ---")
    print(internal_memo)
    print("\\n--- 인스타그램 게시물 ---")
    print(social_media_post)
\`\`\`

### Chapter 4: 다국어 콘텐츠 관리

글로벌 비즈니스 환경에서 언어 장벽은 협업과 정보 접근의 큰 걸림돌이 됩니다. Gemini는 단순한 번역을 넘어, 문맥을 이해하고 뉘앙스를 살리는 고품질 다국어 처리를 통해 이러한 장벽을 허물 수 있습니다.

#### 단순 번역을 넘어서

기존 번역 도구들이 단어와 문장 단위의 번역에 치중했다면, Gemini는 전체 문단의 맥락과 문화적 배경까지 고려하여 자연스러운 번역을 제공합니다. 특히 전문 용어가 많은 기술 문서나 관용적 표현이 사용된 마케팅 자료 번역에서 그 차이가 두드러집니다.

#### 다국어 정보 통합

Gemini의 진정한 강점은 여러 언어로 된 정보를 통합하여 하나의 통찰력을 도출하는 데 있습니다. 이는 글로벌 시장 조사를 하거나, 여러 국가의 고객 피드백을 분석할 때 막대한 생산성 향상을 가져옵니다.

##### 실습: 다국어 소스 기반 시장 조사 요약기

이 워크플로우는 사용자가 한국어로 질문을 입력하면, Gemini가 영어, 일본어, 중국어로 된 관련 웹 기사를 검색하고 그 내용을 종합하여 한국어로 요약 보고서를 생성하는 강력한 예제입니다. (실제 웹 검색 기능은 API에 내장되어 있지 않으므로, 이 예제에서는 검색된 기사 텍스트를 미리 제공하는 형태로 시뮬레이션합니다.)

\`\`\`python
# Jupyter Notebook

if api_key:
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    def synthesize_multilingual_reports(query, articles):
        """
        여러 언어로 된 기사들을 종합하여 한국어로 된 요약 보고서를 생성합니다.
        """
        articles_text = "\\n\\n---\\n\\n".join(
            [f"출처 언어: {lang}\\n내용:\\n{content}" for lang, content in articles.items()]
        )

        prompt = f"""
        # 페르소나
        당신은 글로벌 시장 분석 전문가입니다.

        # 지시사항
        당신은 '{query}'에 대한 시장 조사를 수행하고 있습니다.
        아래에 제공된 여러 언어로 된 '참고 자료'를 모두 종합적으로 분석하여,
        하나의 통합된 한국어 요약 보고서를 작성하세요.

        보고서는 다음 구조를 따라야 합니다:
        1.  **시장 동향 요약:** 모든 자료에서 공통적으로 나타나는 핵심 트렌드
        2.  **지역별 특이사항:** 각 언어권(지역)에서만 나타나는 독특한 관점이나 정보
        3.  **종합 결론 및 시사점:** 분석을 통해 얻을 수 있는 최종적인 통찰력

        # 참고 자료
        {articles_text}
        """
        response = model.generate_content(prompt)
        return response.text

    # 사용자 질문
    user_query = "전기차 배터리 시장의 최신 기술 동향"

    # 각기 다른 언어로 된 가상의 기사 내용
    multilingual_articles = {
        "영어": "A recent study from MIT highlights the emergence of solid-state batteries as a game-changer, promising higher energy density and improved safety compared to traditional lithium-ion batteries. Major automakers are investing billions in this technology.",
        "일본어": "日本のパナソニックは、既存のリチウムイオン電池のコバルト使用量を削減する新しい正極材技術を発表しました。これにより、コスト削減と供給網の安定化が期待されています。(일본의 파나소닉은 기존 리튬이온 배터리의 코발트 사용량을 줄이는 새로운 양극재 기술을 발표했습니다. 이를 통해 비용 절감과 공급망 안정이 기대됩니다.)",
        "중국어": "中国企业宁德时代(CATL)正在大力推广钠离子电池，特别是在低成本、短途城市交通工具领域。尽管能量密度较低，但其丰富的资源和低温性能是巨大优势。(중국 기업 CATL은 특히 저비용, 단거리 도시 교통수단 분야에서 나트륨 이온 배터리를 적극적으로 홍보하고 있습니다. 에너지 밀도는 낮지만, 풍부한 자원과 저온 성능이 큰 장점입니다.)"
    }

    # 다국어 보고서 종합 및 출력
    final_report = synthesize_multilingual_reports(user_query, multilingual_articles)
    display(Markdown(final_report))
\`\`\`
이러한 워크플로우는 개별 번역과 요약을 수작업으로 진행할 때보다 월등히 빠른 속도로 깊이 있는 글로벌 인사이트를 제공하며, 진정한 의미의 '10배 생산성'을 가능하게 합니다.

---

## Part 3: 고급 데이터 처리를 위한 멀티모달리티 활용

이 파트에서는 Gemini의 핵심 역량인 멀티모달리티를 본격적으로 활용하여, 이전에는 수작업이나 전문 소프트웨어가 필요했던 복잡한 작업을 자동화합니다. 텍스트와 이미지가 결합된 문서를 이해하고, 데이터를 시각화하며, 창의적인 이미지를 생성하는 방법을 학습함으로써 '10배 생산성'의 약속을 구체화합니다.

### Chapter 5: 픽셀에서 통찰력으로: 이미지 및 문서 이해

비즈니스 현장에는 PDF 보고서, 스캔된 영수증, 차트가 포함된 프레젠테이션 등 텍스트와 시각 정보가 혼합된 문서가 넘쳐납니다. Gemini의 비전(Vision) 능력은 이러한 문서에서 구조화된 데이터를 추출하고, 시각적 정보를 해석하여 단순한 텍스트 분석을 뛰어넘는 깊이 있는 통찰력을 제공합니다. 특히, 여러 페이지의 PDF 실적 보고서를 분석하여 시각화 차트를 생성하는 것과 같은 복합적인 워크플로우는 멀티모달 AI가 제공하는 생산성 혁신의 대표적인 사례입니다.[10] 이러한 작업은 과거에 분석가가 수작업으로 데이터를 추출하고, 엑셀로 옮겨 차트를 만들던 과정을 단 몇 줄의 코드로 대체할 수 있음을 보여줍니다.

#### 디지털 파일 서기: 문서에서 데이터 추출하기

##### 실습: 이미지 영수증에서 정보 추출하여 JSON으로 변환하기

이 실습에서는 영수증 이미지에서 공급업체, 날짜, 총액, 품목 등의 주요 정보를 자동으로 추출하여 구조화된 JSON 형식으로 반환하는 스크립트를 작성합니다. 이는 경비 처리 자동화 시스템의 핵심 기능이 될 수 있습니다.[10]

사용자의 기업 네트워크 환경을 고려하여, 외부 클라우드 스토리지에서 이미지를 다운로드하는 대신, 파이썬 라이브러리를 사용해 가상의 영수증 이미지를 직접 생성하는 코드를 제공합니다. 이를 통해 네트워크 제약 없이 실습을 진행할 수 있습니다.

\`\`\`python
# Jupyter Notebook

# 필요한 라이브러리 설치
!pip install -q Pillow

import google.generativeai as genai
from PIL import Image, ImageDraw, ImageFont
import io
from IPython.display import display, Markdown

# --- 데이터 준비: 기업 환경 친화적 방식 ---
def create_dummy_invoice_image():
    """가상의 영수증 이미지를 생성합니다."""
    # 흰색 배경의 이미지 생성
    img = Image.new('RGB', (400, 500), color = 'white')
    d = ImageDraw.Draw(img)

    # 폰트 설정 (Colab 기본 폰트 사용)
    try:
        font_header = ImageFont.truetype("/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf", 24)
        font_body = ImageFont.truetype("/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf", 16)
    except IOError:
        font_header = ImageFont.load_default()
        font_body = ImageFont.load_default()

    # 텍스트 추가
    d.text((150, 20), "영수증", fill=(0,0,0), font=font_header)
    d.line((20, 60, 380, 60), fill=(0,0,0), width=1)
    d.text((20, 80), "공급업체: (주)스마트 오피스", fill=(0,0,0), font=font_body)
    d.text((20, 110), "거래일시: 2025-08-22 14:30", fill=(0,0,0), font=font_body)
    d.line((20, 140, 380, 140), fill=(0,0,0), width=1)
    d.text((20, 150), "품목", fill=(0,0,0), font=font_body)
    d.text((200, 150), "수량", fill=(0,0,0), font=font_body)
    d.text((300, 150), "금액", fill=(0,0,0), font=font_body)
    d.text((20, 180), "A4 복사용지", fill=(0,0,0), font=font_body)
    d.text((200, 180), "5", fill=(0,0,0), font=font_body)
    d.text((300, 180), "25,000", fill=(0,0,0), font=font_body)
    d.text((20, 210), "USB 허브", fill=(0,0,0), font=font_body)
    d.text((200, 210), "2", fill=(0,0,0), font=font_body)
    d.text((300, 210), "30,000", fill=(0,0,0), font=font_body)
    d.line((20, 380, 380, 380), fill=(0,0,0), width=1)
    d.text((200, 400), "합계 금액:", fill=(0,0,0), font=font_body)
    d.text((300, 400), "55,000", fill=(0,0,0), font=font_body)

    return img

# --- 원본 코드 (참고용 - 기업 환경에서 차단될 수 있음) ---
# import requests
# url = "https://some-cloud-storage.com/invoice.png"
# response = requests.get(url, stream=True)
# invoice_image_original = Image.open(response.raw)

# --- 기업 환경 친화적 코드 ---
invoice_image = create_dummy_invoice_image()
print("가상 영수증 이미지가 생성되었습니다.")
display(invoice_image)

# --- Gemini를 이용한 정보 추출 ---
if api_key:
    # 멀티모달 입력이 가능한 Pro Vision 모델 사용
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    prompt = """
    이 영수증 이미지에서 다음 정보를 추출하여 JSON 형식으로 반환해줘:
    - \`vendor\` (공급업체 이름)
    - \`date\` (거래 날짜, YYYY-MM-DD 형식)
    - \`total_amount\` (합계 금액, 정수형)
    - \`items\` (품목 목록, 각 품목은 \`name\`, \`quantity\`, \`price\`를 포함하는 객체)
    """

    # 이미지와 텍스트 프롬프트를 함께 전달
    response = model.generate_content([prompt, invoice_image])

    # 응답에서 JSON 부분만 정리하여 출력
    # Gemini는 종종 설명과 함께 JSON을 코드 블록으로 반환합니다.
    import re
    import json

    json_match = re.search(r'\`\`\`json\\n(.*)\\n\`\`\`', response.text, re.DOTALL)
    if json_match:
        json_string = json_match.group(1)
        try:
            parsed_json = json.loads(json_string)
            print("\\n--- 추출된 정보 (JSON) ---")
            print(json.dumps(parsed_json, indent=2, ensure_ascii=False))
        except json.JSONDecodeError:
            print("오류: 유효한 JSON을 파싱할 수 없습니다.")
            print(response.text)
    else:
        print("\\n--- 모델 응답 ---")
        print(response.text)
\`\`\`

#### 시각 자료 해체: 차트와 인포그래픽 분석

보고서나 프레젠테이션의 차트는 많은 정보를 함축하고 있지만, 그 데이터를 재사용하려면 수작업이 필요한 경우가 많습니다. Gemini를 사용하면 차트 이미지를 직접 분석하여 데이터를 추출하고, 그 의미를 해석할 수 있습니다.

##### 실습: 막대 차트 이미지에서 데이터 추출 및 트렌드 설명

다음은 분기별 매출을 나타내는 간단한 막대 차트 이미지를 생성하고, Gemini를 통해 각 분기의 매출 데이터를 추출하며 주요 트렌드를 텍스트로 설명하도록 하는 예제입니다.

\`\`\`python
# Jupyter Notebook

# 필요한 라이브러리 설치
!pip install -q matplotlib

import google.generativeai as genai
from PIL import Image
import matplotlib.pyplot as plt
import io
from IPython.display import display, Markdown

# --- 데이터 준비: 기업 환경 친화적 방식 ---
def create_bar_chart_image():
    """가상의 분기별 매출 막대 차트 이미지를 생성합니다."""
    quarters = ['1Q', '2Q', '3Q', '4Q']
    sales = [120, 150, 135, 180] # 단위: 억원

    fig, ax = plt.subplots()
    ax.bar(quarters, sales)
    ax.set_ylabel('매출 (억원)')
    ax.set_title('2025년 분기별 매출')

    # 이미지를 메모리 버퍼에 저장
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    img = Image.open(buf)
    plt.close(fig)
    return img

# --- 기업 환경 친화적 코드 ---
chart_image = create_bar_chart_image()
print("가상 차트 이미지가 생성되었습니다.")
display(chart_image)

# --- Gemini를 이용한 차트 분석 ---
if api_key:
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    prompt = """
    이 막대 차트를 분석해줘.
    1. 각 분기(1Q, 2Q, 3Q, 4Q)의 매출액을 정확히 읽어서 표(마크다운 형식)로 만들어줘.
    2. 이 차트에서 나타나는 주요 비즈니스 트렌드를 2~3문장으로 설명해줘.
    """

    response = model.generate_content([prompt, chart_image])
    display(Markdown(response.text))
\`\`\`

### Chapter 6: 창의적 및 기술적 이미지 생성

Gemini API는 구글의 최첨단 이미지 생성 모델인 Imagen에 접근할 수 있는 통로를 제공합니다.[11, 12] 이를 통해 사용자는 텍스트 설명만으로 고품질의 이미지를 생성하여 프레젠테이션, 보고서, 마케팅 자료 등에 활용할 수 있습니다. 더 나아가, 기존 이미지를 대화 형식으로 수정하는 것도 가능하여 창의적인 작업의 효율을 크게 높일 수 있습니다.

#### 당신의 온디맨드 그래픽 디자이너

##### 실습: 프레젠테이션을 위한 맞춤 아이콘 생성

다음은 "상승하는 주식 차트"라는 개념을 나타내는 간단하고 평면적인 스타일의 아이콘을 생성하는 스크립트입니다. \`aspect_ratio\`, \`number_of_images\` 등 다양한 파라미터를 제어하여 원하는 결과물을 얻는 방법을 보여줍니다.[11, 13]

\`\`\`python
# Jupyter Notebook

import google.generativeai as genai
from google.generativeai import types
from PIL import Image
from io import BytesIO
from IPython.display import display

# --- Gemini를 이용한 이미지 생성 ---
# 참고: Imagen 모델은 별도의 API 엔드포인트를 사용할 수 있습니다.
# 현재 google-genai SDK에서는 generate_content를 통해 통합적으로 접근하는 방식이 일반적입니다.
# 특정 Imagen 모델 직접 호출은 SDK 버전에 따라 다를 수 있습니다.
# 여기서는 대화형 이미지 생성을 지원하는 모델을 사용합니다.
if api_key:
    # 이미지 생성을 지원하는 모델 선택
    # 모델명은 변경될 수 있으므로 공식 문서를 참고하는 것이 좋습니다.
    # 'gemini-1.5-pro-latest'도 이미지 생성 요청을 이해하고 처리할 수 있습니다.
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    prompt = """
    프레젠테이션에 사용할 아이콘을 만들어줘.
    - 주제: 상승하는 주식 시장 차트
    - 스타일: 심플, 플랫 디자인, 벡터 아이콘 스타일
    - 배경: 흰색 배경
    - 색상: 녹색과 파란색 위주
    - 설명: 위를 향하는 화살표가 있는 긍정적인 느낌의 막대 그래프 아이콘
    """

    # 이미지 생성을 명시적으로 요청
    response = model.generate_content(
        contents=f"'{prompt}' 라는 설명에 맞는 이미지를 생성해줘.",
    )

    # 응답에서 이미지 데이터가 있는지 확인
    # 응답 구조는 모델과 버전에 따라 다를 수 있습니다.
    # 일반적으로 response.parts 또는 유사한 속성에 이미지 데이터가 포함됩니다.
    try:
        if response.parts and hasattr(response.parts[0], 'blob'):
            image_data = response.parts[0].blob.data
            image = Image.open(io.BytesIO(image_data))
            display(image)
        else:
            # 이미지가 직접 생성되지 않은 경우, 모델의 텍스트 응답을 출력
            display(Markdown(f"이미지 생성에 실패했거나, 텍스트 응답이 반환되었습니다:\\n\\n{response.text}"))
            display(Markdown("\\n\\n*참고: \`generate_content\`를 통한 이미지 생성은 모델의 정책 및 기능에 따라 동작이 다를 수 있습니다. Google AI Studio의 'Get Code' 기능을 통해 최신 코드 예제를 확인하는 것이 좋습니다.*"))

    except Exception as e:
        print(f"오류가 발생했습니다: {e}")
        print(response.text)
\`\`\`

#### 대화형 이미지 편집

Gemini의 멀티모달 능력은 기존 이미지를 바탕으로 새로운 이미지를 생성하는 '편집' 작업에서도 빛을 발합니다. 사용자는 이미지를 업로드하고, 텍스트로 원하는 수정 사항을 지시할 수 있습니다.[14]

##### 실습: 제품 사진 배경 변경하기

이 워크플로우에서는 기존 제품 사진을 업로드하고, "이 제품의 배경을 깨끗한 흰색 스튜디오 배경으로 바꿔줘"와 같이 자연어로 요청하여 배경이 제거된 전문가 수준의 제품 이미지를 얻습니다.

\`\`\`python
# Jupyter Notebook

# --- 데이터 준비: 기업 환경 친화적 방식 ---
def create_dummy_product_image():
    """배경이 있는 가상의 제품 이미지를 생성합니다."""
    # 배경 이미지 (예: 나무 질감)
    img = Image.new('RGB', (400, 400), color = '#D2B48C') # 연한 갈색 배경
    d = ImageDraw.Draw(img)

    # 제품 (예: 파란색 원)
    d.ellipse((100, 100, 300, 300), fill='#4682B4', outline=(0,0,0))
    d.text((170, 190), "PRODUCT", fill='white', font=ImageFont.load_default())
    return img

# --- 기업 환경 친화적 코드 ---
product_image = create_dummy_product_image()
print("가상 제품 이미지가 생성되었습니다.")
display(product_image)

# --- Gemini를 이용한 이미지 편집 ---
if api_key:
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    prompt = "이 이미지에서 제품(파란색 원)만 남기고, 배경을 깨끗한 흰색(#FFFFFF)으로 변경해줘."

    # 이미지와 편집 지시를 함께 전달
    response = model.generate_content([prompt, product_image])

    try:
        if response.parts and hasattr(response.parts[0], 'blob'):
            edited_image_data = response.parts[0].blob.data
            edited_image = Image.open(io.BytesIO(edited_image_data))
            print("\\n--- 배경이 변경된 이미지 ---")
            display(edited_image)
        else:
            display(Markdown(f"이미지 편집에 실패했거나, 텍스트 응답이 반환되었습니다:\\n\\n{response.text}"))

    except Exception as e:
        print(f"오류가 발생했습니다: {e}")
        print(response.text)
\`\`\`

### Chapter 7: 자연어를 이용한 데이터 시각화

데이터 시각화는 복잡한 데이터를 이해하기 쉽게 만드는 필수 과정이지만, \`matplotlib\`나 \`seaborn\`과 같은 라이브러리 코드를 작성하는 것은 번거로울 수 있습니다. Gemini를 활용하면, 데이터와 원하는 차트 형태를 자연어로 설명하여 필요한 파이썬 코드를 자동으로 생성할 수 있습니다. 이는 Part 3의 정점으로, 텍스트(지시)와 코드(결과)를 넘나드는 Gemini의 강력한 능력을 보여주는 사례입니다.[10]

#### 설명에서 다이어그램으로

##### 실습: 자연어 설명으로 Matplotlib 차트 코드 생성하기

이 실습에서는 "1분기부터 4분기까지의 판매 데이터가 있습니다. 각 분기별 판매량을 보여주는 막대 차트를 만들어주세요."와 같은 자연어 요청을 바탕으로, Gemini가 실제 실행 가능한 \`matplotlib\` 코드를 생성하도록 합니다.

\`\`\`python
# Jupyter Notebook

import google.generativeai as genai
import matplotlib.pyplot as plt
import pandas as pd
from IPython.display import display, Markdown

if api_key:
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    # 데이터와 시각화 요구사항을 자연어로 설명
    prompt_for_code = """
    # 지시사항
    당신은 데이터 시각화 전문가입니다.
    아래에 제공된 '데이터'와 '요구사항'을 바탕으로, Python의 \`matplotlib\` 라이브러리를 사용하여 데이터를 시각화하는 완전한 코드를 작성해주세요.
    코드는 바로 복사해서 실행할 수 있어야 합니다. 주석을 포함하여 코드를 이해하기 쉽게 설명해주세요.

    # 데이터
    - 데이터 형식: Pandas DataFrame
    - 데이터 내용: 2025년 분기별 제품 판매량
      - 1분기: 850개
      - 2분기: 1100개
      - 3분기: 950개
      - 4분기: 1300개

    # 요구사항
    1. 분기별 판매량을 나타내는 막대 차트(bar chart)를 생성하세요.
    2. X축 레이블은 '분기'로, Y축 레이블은 '판매량 (개)'로 설정하세요.
    3. 차트의 전체 제목은 '2025년 분기별 제품 판매량'으로 지정하세요.
    4. 각 막대에 판매량 수치를 표시해주세요.
    5. 최종적으로 \`plt.show()\`를 호출하여 차트를 표시하세요.
    """

    response = model.generate_content(prompt_for_code)

    # 생성된 코드 추출 및 출력
    import re
    code_match = re.search(r'\`\`\`python\\n(.*)\\n\`\`\`', response.text, re.DOTALL)
    if code_match:
        generated_code = code_match.group(1)
        print("--- Gemini가 생성한 Matplotlib 코드 ---")
        print(generated_code)

        # 생성된 코드 직접 실행
        print("\\n--- 생성된 코드 실행 결과 ---")
        try:
            exec(generated_code)
        except Exception as e:
            print(f"코드 실행 중 오류 발생: {e}")
    else:
        print("Python 코드를 찾을 수 없습니다.")
        display(Markdown(response.text))
\`\`\`

#### 반복적 개선

시각화 작업은 한 번에 끝나지 않는 경우가 많습니다. Gemini와의 대화를 통해 초기 차트를 점진적으로 개선해 나갈 수 있습니다. 예를 들어, 위에서 생성된 코드를 바탕으로 "이제 막대 색상을 파란색으로 바꾸고, Y축의 최대값을 1500으로 설정해줘"와 같은 추가 요청을 보내면, Gemini는 수정된 코드를 다시 생성해줍니다. 이러한 대화형 방식은 코딩에 익숙하지 않은 사용자도 복잡한 시각화를 손쉽게 만들 수 있도록 지원합니다.

---

## Part 4: Google Workspace에서의 통합 및 자동화 워크플로우 구축

이 파트에서는 Gemini의 능력을 사용자의 일상 업무 환경인 Google Workspace와 직접 연결합니다. 이를 통해 개인적인 스크립트 작성을 넘어, 팀의 공유된 문서와 데이터를 기반으로 하는 강력한 자동화 워크플로우를 구축하는 방법을 다룹니다. 이 과정의 가장 큰 기술적 과제는 인증(Authentication)이며, 본 가이드에서는 이 부분을 명확하고 단계적으로 설명하여 사용자가 성공적으로 통합을 완료할 수 있도록 돕습니다.

### Chapter 8: Gemini와 Google Sheets: AI 기반 스프레드시트

#### 전제 조건: Google Workspace 인증 정복하기

단순한 Gemini API 키 인증 방식과 달리, Google Workspace(Sheets, Docs, Drive 등)의 데이터에 접근하기 위해서는 사용자의 권한을 위임받는 OAuth 2.0 인증 방식이 필요합니다. 이 과정은 처음 접하는 사용자에게는 복잡하게 느껴질 수 있으나, 한 번 설정해두면 강력한 자동화의 문이 열립니다.[15, 16] 공식 문서는 방대하므로, 여기서는 핵심적인 절차를 간소화하여 안내합니다.

**OAuth 2.0 설정 단계 요약:**

1.  **Google Cloud 프로젝트 생성 및 API 활성화:**
    * [Google Cloud Console](https://console.cloud.google.com/)에 접속하여 새 프로젝트를 생성하거나 기존 프로젝트를 선택합니다.
    * 'API 및 서비스' > '라이브러리'에서 'Google Sheets API'와 'Google Drive API'를 검색하여 '사용 설정'합니다.

2.  **OAuth 동의 화면 구성:**
    * 'API 및 서비스' > 'OAuth 동의 화면'으로 이동합니다.
    * 'User Type'을 '외부'로 선택하고 '만들기'를 클릭합니다.
    * 앱 이름(예: "Gemini Sheets 자동화"), 사용자 지원 이메일, 개발자 연락처 정보를 입력합니다.
    * '범위' 단계는 일단 건너뛰고 저장 후 계속합니다.
    * '테스트 사용자' 단계에서 자신의 구글 계정 이메일 주소를 추가하고 저장합니다. 이는 앱이 게시되기 전, 승인된 사용자만 앱을 테스트할 수 있도록 하기 위함입니다.

3.  **OAuth 2.0 클라이언트 ID 생성:**
    * 'API 및 서비스' > '사용자 인증 정보'로 이동합니다.
    * '+ 사용자 인증 정보 만들기' > 'OAuth 클라이언트 ID'를 선택합니다.
    * '애플리케이션 유형'으로 '데스크톱 앱'을 선택하고 이름을 지정한 후 '만들기'를 클릭합니다.
    * 생성된 클라이언트 ID와 클라이언트 보안 비밀번호가 표시됩니다. 오른쪽의 다운로드 아이콘을 클릭하여 JSON 파일을 다운로드합니다.
    * 다운로드한 파일의 이름을 \`client_secret.json\`으로 변경하고, Jupyter Notebook을 실행하는 작업 디렉터리에 저장합니다.

4.  **파이썬 라이브러리 설치:**
    Google API와 OAuth 2.0 인증을 처리하기 위한 라이브러리들을 설치합니다.

    \`\`\`python
   !pip install -q --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
    \`\`\`

이제 \`client_secret.json\` 파일을 사용하여 사용자의 Google 계정 접근 권한을 얻는 코드를 작성할 준비가 되었습니다. 아래 코드는 처음 실행 시 브라우저를 통해 구글 로그인 및 권한 동의를 요청하며, 성공적으로 인증되면 \`token.json\`이라는 파일을 생성하여 다음 실행부터는 자동으로 로그인합니다.[16, 17]

\`\`\`python
# Jupyter Notebook

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import os.path

# 필요한 권한 범위(Scopes)를 정의합니다.
# Sheets와 Drive에 대한 읽기/쓰기 권한을 요청합니다.
SCOPES = ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive']

def authenticate_google_workspace():
    """Google Workspace API에 대한 인증을 처리하고 서비스 객체를 반환합니다."""
    creds = None
    # token.json 파일은 사용자의 액세스 및 리프레시 토큰을 저장합니다.
    if os.path.exists('token.json'):
        creds = Credentials.from_authorized_user_file('token.json', SCOPES)
    # 유효한 자격 증명이 없으면 사용자가 로그인하도록 합니다.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'client_secret.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # 다음 실행을 위해 자격 증명을 저장합니다.
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
    return creds

try:
    credentials = authenticate_google_workspace()
    sheets_service = build('sheets', 'v4', credentials=credentials)
    drive_service = build('drive', 'v3', credentials=credentials)
    print("Google Workspace 인증에 성공했습니다.")
except Exception as e:
    print(f"인증 중 오류 발생: {e}")
    print("client_secret.json 파일이 올바른 위치에 있는지, OAuth 동의 화면 설정이 완료되었는지 확인하세요.")

\`\`\`

#### 스프레드시트 작업 자동화

##### 실습: Google Sheet 데이터 정제 및 표준화

이 실습에서는 고객 목록이 포함된 Google Sheet를 읽어와, 주소나 회사명 형식이 제각각인 데이터를 Gemini를 통해 일관된 형식으로 정제한 후, 새로운 시트에 결과를 작성하는 자동화 스크립트를 구현합니다.

\`\`\`python
# Jupyter Notebook

import pandas as pd
import json

# --- 데이터 준비: 실습용 Google Sheet 생성 ---
# 이 코드는 처음 한 번만 실행하여 실습용 시트를 생성합니다.
# 위 인증 코드가 성공적으로 실행되었다고 가정합니다.

try:
    # 1. 새로운 스프레드시트 생성
    spreadsheet_body = {
        'properties': {
            'title': 'Gemini 실습 - 고객 데이터 정제'
        }
    }
    spreadsheet = sheets_service.spreadsheets().create(body=spreadsheet_body).execute()
    SPREADSHEET_ID = spreadsheet['spreadsheetId']
    print(f"새 스프레드시트가 생성되었습니다. ID: {SPREADSHEET_ID}")
    print(f"링크: {spreadsheet['spreadsheetUrl']}")

    # 2. 샘플 데이터 준비 및 시트에 쓰기
    sample_data = [
        ['회사명', '주소'],
        ['(주)가나다 상사', '서울시 강남구 테헤란로 123번지'],
        ['주식회사 라마바', '경기도 성남시 분당구 판교역로 456'],
        ['사과전자(주)', '수원시 영통구'],
        ['(주) 가나다상사', '서울 강남 테헤란로 123']
    ]
    body = {
        'values': sample_data
    }
    sheets_service.spreadsheets().values().update(
        spreadsheetId=SPREADSHEET_ID, range='Sheet1!A1',
        valueInputOption='RAW', body=body).execute()
    print("샘플 데이터가 시트에 기록되었습니다.")

except NameError:
    print("인증이 먼저 필요합니다. 위 인증 코드를 실행해주세요.")
    SPREADSHEET_ID = "여기에_생성된_스프레드시트_ID를_붙여넣으세요"
except Exception as e:
    print(f"시트 생성 중 오류 발생: {e}")
    SPREADSHEET_ID = "여기에_생성된_스프레드시트_ID를_붙여넣으세요"


# --- Gemini를 이용한 데이터 정제 ---
if 'credentials' in locals() and api_key:
    # 1. 시트에서 데이터 읽기
    result = sheets_service.spreadsheets().values().get(
        spreadsheetId=SPREADSHEET_ID, range='Sheet1!A:B').execute()
    values = result.get('values', [])
    df = pd.DataFrame(values[1:], columns=values[0])
    print("\\n--- 원본 데이터 ---")
    display(df)

    # 2. Gemini에 데이터 정제 요청
    model = genai.GenerativeModel('gemini-1.5-pro-latest')
    prompt = f"""
    다음 고객 데이터를 정제하고 표준화해줘.
    - 회사명: '(주)'와 같은 표기는 통일하고, 공백을 제거해줘. 예: (주)가나다 상사 -> (주)가나다상사
    - 주소: '시', '구', '동'을 포함하는 표준 형식으로 변환해줘.

    결과는 JSON 배열 형식으로 반환해줘. 각 객체는 'original_company', 'cleaned_company', 'original_address', 'cleaned_address' 키를 가져야 해.

    데이터:
    {df.to_json(orient='records', force_ascii=False)}
    """
    response = model.generate_content(prompt)

    # 3. 결과 파싱 및 새 시트에 쓰기
    try:
        # 응답에서 JSON 추출
        json_match = re.search(r'\`\`\`json\\n(.*)\\n\`\`\`', response.text, re.DOTALL)
        if json_match:
            json_string = json_match.group(1)
            cleaned_data = json.loads(json_string)
            cleaned_df = pd.DataFrame(cleaned_data)

            print("\\n--- 정제된 데이터 ---")
            display(cleaned_df)

            # 새 시트('Cleaned_Data')에 결과 쓰기
            new_sheet_name = 'Cleaned_Data'
            requests = [
                {'addSheet': {'properties': {'title': new_sheet_name}}}
            ]
            sheets_service.spreadsheets().batchUpdate(
                spreadsheetId=SPREADSHEET_ID, body={'requests': requests}).execute()

            update_body = {
                'values': [cleaned_df.columns.values.tolist()] + cleaned_df.values.tolist()
            }
            sheets_service.spreadsheets().values().update(
                spreadsheetId=SPREADSHEET_ID, range=f'{new_sheet_name}!A1',
                valueInputOption='RAW', body=update_body).execute()
            print(f"'{new_sheet_name}' 시트에 정제된 데이터가 기록되었습니다.")

    except Exception as e:
        print(f"\\n데이터 처리 또는 시트 쓰기 중 오류 발생: {e}")
        print("Gemini 응답:", response.text)
\`\`\`

##### 실습: "영어로 된 공식" 도구

스프레드시트 사용자는 종종 원하는 계산을 어떻게 공식으로 만들어야 할지 모를 때가 있습니다. 이 실습에서는 사용자가 셀에 "A열의 모든 값을 더해줘"와 같이 자연어로 계산을 설명하면, Gemini가 올바른 Google Sheets 공식을 생성하여 해당 셀에 삽입하는 도구를 만듭니다.

### Chapter 9: Google Docs 및 Slides 향상시키기

문서와 프레젠테이션 자료를 만드는 데 소요되는 시간을 Gemini를 통해 획기적으로 단축할 수 있습니다. 개요만으로 보고서 초안을 만들고, 주제만으로 발표 자료의 전체 내용을 자동으로 생성하는 워크플로우를 구현합니다.

#### 자동화된 문서 조립

##### 실습: 개요 기반 Google Docs 보고서 초안 생성

이 스크립트는 구조화된 텍스트 개요를 입력받아, Gemini를 통해 각 섹션의 내용을 풍부하게 채운 후, Google Docs API를 사용하여 새로운 문서 파일로 생성합니다.

\`\`\`python
# Jupyter Notebook

# 위 인증 코드가 성공적으로 실행되었다고 가정합니다.
if 'credentials' in locals() and api_key:
    docs_service = build('docs', 'v1', credentials=credentials)
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    # 1. 보고서 개요 정의
    report_title = "AI 도입에 따른 업무 생산성 변화 분석"
    report_outline = """
    1. 서론: AI 기술의 부상과 연구 목적
    2. 본론 1: AI 도입 성공 사례 분석 (A사, B사)
    3. 본론 2: AI 도입에 따른 직무별 생산성 변화 측정
    4. 결론: 성공적인 AI 도입을 위한 제언
    """

    # 2. Gemini에 개요를 바탕으로 전체 내용 생성 요청
    prompt = f"""
    '{report_title}'라는 제목과 아래 '개요'를 바탕으로 상세한 보고서 전체 내용을 작성해줘.
    각 개요 항목에 대해 풍부한 설명을 담은 여러 문단을 생성해줘.

    개요:
    {report_outline}
    """
    response = model.generate_content(prompt)
    report_content = response.text

    # 3. Google Docs API를 사용하여 새 문서 생성 및 내용 삽입
    try:
        doc_body = {'title': report_title}
        doc = docs_service.documents().create(body=doc_body).execute()
        DOC_ID = doc['documentId']
        print(f"새 Google Doc이 생성되었습니다. ID: {DOC_ID}")

        requests = [
            {'insertText': {
                'location': {'index': 1},
                'text': report_content
            }}
        ]
        docs_service.documents().batchUpdate(
            documentId=DOC_ID, body={'requests': requests}).execute()

        print(f"문서에 내용이 성공적으로 삽입되었습니다.")
        print(f"링크: https://docs.google.com/document/d/{DOC_ID}/edit")

    except Exception as e:
        print(f"문서 생성 중 오류 발생: {e}")
\`\`\`

#### 개요에서 프레젠테이션까지 단 몇 분 만에

##### 실습: 주제 개요 기반 Google Slides 자동 생성

이 워크플로우는 프레젠테이션의 각 슬라이드 제목을 담은 간단한 개요를 바탕으로, Gemini가 각 슬라이드의 본문 내용과 발표자 노트를 모두 생성하고, Google Slides API를 통해 실제 프레젠테이션 파일을 만드는 과정을 자동화합니다.

\`\`\`python
# Jupyter Notebook

# 위 인증 코드가 성공적으로 실행되었다고 가정합니다.
if 'credentials' in locals() and api_key:
    slides_service = build('slides', 'v1', credentials=credentials)
    model = genai.GenerativeModel('gemini-1.5-pro-latest')

    # 1. 프레젠테이션 개요 (슬라이드 제목 목록)
    presentation_title = "Gemini를 활용한 업무 자동화"
    slide_titles = [
        "표지: Gemini를 활용한 업무 자동화",
        "1. 반복 업무의 문제점",
        "2. Gemini란 무엇인가? (멀티모달 AI)",
        "3. 활용 사례 1: 이메일 및 보고서 작성 자동화",
        "4. 활용 사례 2: 데이터 추출 및 분석",
        "5. 도입 효과 및 기대 결과",
        "6. Q&A"
    ]

    # 2. Gemini에 각 슬라이드 내용 및 발표자 노트 생성 요청
    prompt = f"""
    '{presentation_title}'라는 제목의 프레젠테이션을 만들려고 해.
    아래는 각 슬라이드의 제목 목록이야.
    각 슬라이드에 들어갈 '핵심 내용(3-4개 불릿 포인트)'과 '발표자 노트(청중에게 설명할 대본)'를 생성해줘.

    결과는 JSON 배열 형식으로 반환해줘. 각 객체는 'title', 'content', 'speaker_notes' 키를 가져야 해.

    슬라이드 제목 목록:
    {json.dumps(slide_titles, ensure_ascii=False)}
    """
    response = model.generate_content(prompt)

    # 3. Google Slides API로 프레젠테이션 생성
    try:
        # JSON 응답 파싱
        json_match = re.search(r'\`\`\`json\\n(.*)\\n\`\`\`', response.text, re.DOTALL)
        slide_contents = json.loads(json_match.group(1))

        # 프레젠테이션 생성
        presentation_body = {'title': presentation_title}
        presentation = slides_service.presentations().create(body=presentation_body).execute()
        PRESENTATION_ID = presentation['presentationId']
        print(f"새 프레젠테이션이 생성되었습니다. ID: {PRESENTATION_ID}")

        # 각 슬라이드 생성
        requests = []
        for i, slide in enumerate(slide_contents):
            # 새 슬라이드 추가
            slide_id = f"slide_{i}"
            requests.append({'createSlide': {'objectId': slide_id}})

            # 제목 추가
            requests.append({'insertText': {
                'objectId': slide_id,
                'text': slide['title'],
                'insertionIndex': 0
            }})

            # 내용 추가
            requests.append({'insertText': {
                'objectId': slide_id,
                'text': '\\n' + slide['content'],
            }})

            # 발표자 노트 추가 (첫 번째 슬라이드의 노트 셰이프 ID를 찾아 사용)
            # (간략화를 위해 실제 코드에서는 슬라이드별 노트 셰이프 ID를 조회해야 함)

        slides_service.presentations().batchUpdate(
            presentationId=PRESENTATION_ID, body={'requests': requests}).execute()

        print(f"프레젠테이션 생성이 완료되었습니다.")
        print(f"링크: https://docs.google.com/presentation/d/{PRESENTATION_ID}/edit")

    except Exception as e:
        print(f"프레젠테이션 생성 중 오류 발생: {e}")
        print("Gemini 응답:", response.text)
\`\`\`

---

## Part 5: 팀을 위한 맞춤형 AI 도구 프로토타이핑

이 마지막 파트에서는 지금까지 습득한 모든 기술을 종합하여, 개인적인 스크립트를 넘어 팀 전체가 사용할 수 있는 공유 가능한 애플리케이션을 만드는 방법을 배웁니다. 이를 통해 사용자는 Gemini 기술의 단순한 소비자를 넘어, 동료들의 생산성을 높이는 AI 도구 개발자로 거듭날 수 있습니다.

### Chapter 10: 나만의 AI 비서 만들기: Streamlit을 활용한 최종 프로젝트

본 과정의 대미를 장식할 최종 프로젝트는 학습한 모든 기술을 집약하는 것입니다. Google의 'NotebookLM'과 같은 문서 기반 질의응답 도구는 AI 생산성 도구의 정점이라 할 수 있으며, 우리는 이를 목표로 삼아 '미니 NotebookLM'을 직접 구축해볼 것입니다.[18, 19, 20] 이 프로젝트를 위해, 파이썬 스크립트를 손쉽게 웹 애플리케이션으로 만들어주는 'Streamlit' 프레임워크를 사용할 것입니다.[21, 22, 23] 최종 결과물은 사용자가 문서를 업로드하고, 그 내용에 대해 자연어로 대화할 수 있는 실용적인 AI 비서가 될 것입니다.

#### Streamlit 소개: 스크립트에서 앱으로

Streamlit은 데이터 과학자와 개발자가 최소한의 코드로 인터랙티브한 웹 UI를 만들 수 있게 해주는 오픈소스 파이썬 라이브러리입니다. 복잡한 웹 프레임워크(HTML, CSS, JavaScript)를 배우지 않고도, 익숙한 파이썬 코드에 \`st.title()\`, \`st.button()\`, \`st.file_uploader()\`와 같은 간단한 함수를 추가하는 것만으로 데이터 시각화, 모델 데모, 내부 도구 등을 빠르게 제작할 수 있습니다.

**Streamlit 설치:**
\`\`\`bash
pip install -q streamlit
\`\`\`

**기본 사용법:**
\`app.py\`라는 파일을 만들고 아래 코드를 작성합니다.
\`\`\`python
# app.py
import streamlit as st

st.title("My First Streamlit App")

name = st.text_input("Enter your name:")

if st.button("Say Hello"):
    st.write(f"Hello, {name}!")
\`\`\`
터미널에서 \`streamlit run app.py\`를 실행하면, 웹 브라우저에 "My First Streamlit App"이라는 제목과 함께 입력 필드, 버튼이 있는 웹페이지가 나타납니다. 이처럼 직관적인 방식이 Streamlit의 가장 큰 장점입니다.

#### 최종 프로젝트: 문서 Q&A 어시스턴트

이 프로젝트는 다음 기능을 갖춘 웹 애플리케이션을 구축하는 것을 목표로 합니다.

1.  **파일 업로드:** 사용자가 PDF 또는 TXT 파일을 웹 인터페이스를 통해 업로드할 수 있습니다.
2.  **문서 처리 및 요약:** 업로드된 파일의 내용을 Gemini를 사용하여 분석하고 내부적으로 요약합니다.
3.  **대화형 Q&A:** 사용자가 업로드한 문서 내용에 대해 질문하면, Gemini가 문서 내용을 기반으로 답변하는 챗봇 인터페이스를 제공합니다.
4.  **원클릭 기능:** "핵심 요약 생성", "FAQ 목록 만들기"와 같은 버튼을 클릭하면, 문서 전체에 대한 특정 작업을 수행하여 결과를 보여줍니다. 이는 NotebookLM의 핵심 기능을 모방한 것입니다.[18, 19]

##### 프로젝트 구현 (Jupyter Notebook/Python 스크립트)

이 코드는 Streamlit 애플리케이션의 전체 로직을 담고 있습니다. 이 코드를 \`qa_app.py\`와 같은 파일로 저장하고, 터미널에서 \`streamlit run qa_app.py\` 명령으로 실행하세요.

\`\`\`python
# 파일명: qa_app.py

import streamlit as st
import google.generativeai as genai
import fitz  # PyMuPDF
import os

# --- 페이지 설정 및 API 키 입력 ---
st.set_page_config(page_title="문서 Q&A 어시스턴트", layout="wide")
st.title("📄 나만의 문서 Q&A 어시스턴트 (Mini-NotebookLM)")
st.write("PDF 또는 TXT 파일을 업로드하고, 문서 내용에 대해 자유롭게 질문하세요.")

# 사이드바에서 API 키 입력 받기
with st.sidebar:
    st.header("API Key 설정")
    # Streamlit의 secrets 관리 기능을 사용하거나 직접 입력
    try:
        # Streamlit Cloud 배포 시 secrets.toml 사용
        api_key = st.secrets["GEMINI_API_KEY"]
    except:
        api_key = st.text_input("Gemini API Key를 입력하세요:", type="password")

    if api_key:
        try:
            genai.configure(api_key=api_key)
            st.success("API 키가 성공적으로 설정되었습니다.")
        except Exception as e:
            st.error(f"API 키 설정 오류: {e}")
    else:
        st.warning("Gemini API 키를 입력해주세요.")


# --- 핵심 함수 정의 ---
def get_text_from_file(uploaded_file):
    """업로드된 파일에서 텍스트를 추출합니다."""
    text = ""
    if uploaded_file.type == "application/pdf":
        try:
            with fitz.open(stream=uploaded_file.read(), filetype="pdf") as doc:
                for page in doc:
                    text += page.get_text()
        except Exception as e:
            return f"PDF 처리 오류: {e}", None
    elif uploaded_file.type == "text/plain":
        text = uploaded_file.read().decode("utf-8")
    else:
        return "지원하지 않는 파일 형식입니다. (PDF, TXT만 가능)", None
    return None, text

def get_gemini_response(prompt, context=""):
    """Gemini 모델로부터 응답을 생성합니다."""
    if not api_key:
        return "API 키가 설정되지 않았습니다."
    try:
        model = genai.GenerativeModel('gemini-1.5-pro-latest')
        full_prompt = f"""
        # 문서 내용
        {context}

        ---

        # 질문
        {prompt}

        # 지시사항
        당신은 제공된 '문서 내용'을 완벽하게 이해하고, 그 내용을 바탕으로만 '질문'에 답변하는 AI 어시스턴트입니다.
        문서에 없는 내용은 답변하지 마세요.
        """
        response = model.generate_content(full_prompt)
        return response.text
    except Exception as e:
        return f"Gemini API 호출 오류: {e}"


# --- Streamlit UI 구성 ---

# 세션 상태 초기화
if 'document_text' not in st.session_state:
    st.session_state.document_text = None
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []

# 파일 업로더
uploaded_file = st.file_uploader("분석할 파일을 선택하세요 (PDF, TXT)", type=["pdf", "txt"])

if uploaded_file is not None:
    with st.spinner("파일을 처리 중입니다..."):
        error, document_text = get_text_from_file(uploaded_file)
        if error:
            st.error(error)
        else:
            st.session_state.document_text = document_text
            st.session_state.chat_history = [] # 새 파일 업로드 시 채팅 기록 초기화
            st.success(f"'{uploaded_file.name}' 파일이 성공적으로 처리되었습니다. 이제 질문을 시작할 수 있습니다.")

# 문서가 처리된 경우에만 나머지 UI 표시
if st.session_state.document_text:
    st.markdown("---")

    # 원클릭 기능 버튼
    col1, col2 = st.columns(2)
    with col1:
        if st.button("📑 핵심 내용 요약하기"):
            with st.spinner("요약 중..."):
                summary_prompt = "이 문서의 핵심 내용을 3-5개의 불릿 포인트로 요약해줘."
                summary = get_gemini_response(summary_prompt, st.session_state.document_text)
                st.session_state.chat_history.append(("system", summary))

    with col2:
        if st.button("❓ 예상 질문(FAQ) 생성하기"):
            with st.spinner("FAQ 생성 중..."):
                faq_prompt = "이 문서를 기반으로 사람들이 궁금해할 만한 예상 질문과 그에 대한 답변 5개를 만들어줘."
                faq = get_gemini_response(faq_prompt, st.session_state.document_text)
                st.session_state.chat_history.append(("system", faq))

    st.markdown("---")

    # 채팅 인터페이스
    st.header("💬 문서에 대해 질문하기")

    # 채팅 기록 표시
    for role, message in st.session_state.chat_history:
        with st.chat_message(role):
            st.markdown(message)

    # 사용자 입력
    if user_prompt := st.chat_input("문서 내용에 대해 질문하세요..."):
        # 사용자 질문을 채팅 기록에 추가
        st.session_state.chat_history.append(("user", user_prompt))
        with st.chat_message("user"):
            st.markdown(user_prompt)

        # AI 응답 생성 및 표시
        with st.spinner("답변을 생성 중입니다..."):
            response = get_gemini_response(user_prompt, st.session_state.document_text)
            st.session_state.chat_history.append(("assistant", response))
            with st.chat_message("assistant"):
                st.markdown(response)

else:
    st.info("시작하려면 파일을 업로드하세요.")

\`\`\`
이 최종 프로젝트는 본 가이드에서 다룬 모든 핵심 요소를 통합합니다. 파일 처리, Gemini API를 통한 텍스트 생성 및 이해(Q&A, 요약, FAQ 생성), 그리고 Streamlit을 통한 사용자 친화적인 인터페이스 구축까지, 사용자는 이 프로젝트를 완성함으로써 Gemini를 활용한 실용적인 AI 애플리케이션을 처음부터 끝까지 개발하는 경험을 하게 됩니다. 이는 단순한 기술 습득을 넘어, 실제 업무 현장에서 마주하는 문제를 AI로 해결하는 능력을 갖추게 되었음을 의미하며, '10배의 생산성 향상'이라는 목표를 달성하는 구체적인 결과물이라 할 수 있습니다.
`;

        // Function to render the markdown
        function renderMarkdown() {
            const contentDiv = document.getElementById('content');
            // Convert markdown to HTML using marked.js
            contentDiv.innerHTML = marked.parse(markdownContent);
            // Apply syntax highlighting to all code blocks
            hljs.highlightAll();
        }

        // Run the function when the page loads
        document.addEventListener('DOMContentLoaded', renderMarkdown);
    </script>

</body>
</html>
